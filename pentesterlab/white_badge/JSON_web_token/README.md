# Pentesterlab JSON Web Token

> Saikat Karmakar | SEPT 1 : 2021

---


## Introduction

This course details the exploitation of a weakness in JSON Web Token (JWT). In this application, JWT is used for authentication. Upon successful login, the user is issued a JWT in a cookie.

If you feel confident, you can try to do this exercise without following the course; then you can come back to the course to read some details and tips. If you want to do it by yourself, you can follow the following steps:

    Create one user.
    Inspect the token.
    Tamper the token to gain admin access.


## JSON Web Token

JSON Web Tokens are a storage mechanism for data. JWT can provide the following security mechanisms:

    Encryption.
    Signature.

JWT follow the following pattern:

Base64(Header).Base64(Data).Base64(Signature)

The header contains information on the security mechanisms used. For example, the following header: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXUyJ9 contains the following information:

```json
{ "alg": "HS256", 
  "typ": "JWS"
}
```

The header is signed. However, it's a catch 22 problem: if you want to sign the header, you will need the header to verify the signature and the signature to verify the header. Signing the header doesn't prevent an attacker to tamper with the header and change the algorithm used for the signature. However, the server will still verify the signature (and therefore the content of the header).

## The vulnerability

This issue was originally discussed in the following blog post: https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/.

In this article, Tim McLean discussed multiple issues in the signature mechanism used by JWT. In this exercise, we are going to focus on the first issue.

Multiple signature methods can be used to ensure the integrity of JWT:

    RSA based
    Elliptic curves
    HMAC
    None

Like SSL (with the NULL Cipher), JWT support a None algorithm for signature. This was probably introduced to debug applications. However, this can have a severe impact on the security of the application.

## Exploitation

To exploit this vulnerability, you just need to decode the JWT and change the algorithm used for the signature. Then you can submit your new JWT. However, this won't work unless you remove the signature. If you think like a developer, it actually makes a lot of sense. If you had to develop a JWT library, you will start by generating all the signatures you need to support as it allows you to compare your implementation to others. Then you will create a generic verification method that compare what you get from the JWT with the signature you are generating (based on the algorithm in the header). Since you don't generate any signature with the None algorithm, you will ensure that the signature is empty. Therefore, as an attacker, you need to provide an empty signature.
